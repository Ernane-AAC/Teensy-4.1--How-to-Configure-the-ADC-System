// ========================================================================================
// Data acquisition on the Teensy 4.1 ADC1
// UNVERSIDADE FEDERAL DE UBERLÂNDIA - Faculdade de Engenharia Elétrica
// Subject: DSP-EPS - Prof. Ernane A. A. Coelho - http://lattes.cnpq.br/9183492978798433
// This code is for demonstration purposes only, showing how to perform data acquisition using the Teensy 4.1 ADC1 with a hardware trigger.
// Code characteristics:
// - Data acquisition is performed over the AO channel of the Teensy 4.1 ADC1.
// - The acquisition sequence composed of 4 channels from ADC1 will be controlled by ADC_ETC. To reduce the hardware resources used in the tests, 
//   the sequence will consist of 4 readings from the same channel (single voltage sensor connected to channel A0)
// - The ADC_ETC trigger will be generated by submodule 2 of FlexPWM 4.
// - The carrier frequency of the FlexPWM4SM2 will be 12kHz. Trigger0 (half-cycle) and trigger1 (full-cycle) will be used, 
//   implying double sampling per PWM cycle, generating a sampling frequency of 24kHz.
// - For illustrative purposes only, in addition to the trigger signals, the FlexPWM4SM2 submodule generates a sinusoidal pulse width modulation 
//   at the PWMA output (PWMB will be a complementary signal of PWMA). The PWM signal is calculated in real time. Use an external low-pass filter
//   to visualize the sinusoidal signal on an oscilloscope. For example, one can use a low-pass filter corresponding to two cascaded RC sections 
//   (R=4k99;C=10nF), which implies a cutoff frequency of 3189.5 Hz and a carrier attenuation of approximately -35.1dB (x0.0176) at 24kHz, 
//   disregarding the loading of one section on the other.
// - Data acquisition will be performed when the operator sends the character "1" via serial. The loop function checks the received characters, 
//   executes the acquisition if the character is equal to "1", and sends the acquisition results back via serial.
// ========================================================================================
#include "Arduino.h"
#include <imxrt.h>
#include <math.h>

//Teensy 4.1 Analog Inputs:
//Teensy Analog Input | Teensy Pin | iMXRT1062 pad | ADC1 IN | ADC2 IN |
#define A0 7      //  |      14    |    AD_B1_02   |   IN7   |   IN7   |
#define A1 8      //  |      15    |    AD_B1_03   |   IN8   |   IN8   |
#define A2 12     //  |      16    |    AD_B1_07   |   IN12  |   IN12  |
#define A3 11     //  |      17    |    AD_B1_06   |   IN11  |   IN11  |
#define A4 6      //  |      18    |    AD_B1_01   |   IN6   |   IN6   |
#define A5 5      //  |      19    |    AD_B1_00   |   IN5   |   IN5   |
#define A6 15     //  |      20    |    AD_B1_10   |   IN15  |   IN15  |
#define A7 0      //  |      21    |    AD_B1_11   |   IN0   |   IN0   |
// - For other channels, see the Teensy 4.1 documentation and Table 66-2, ADC external signals, page 3405,
//   i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors.

volatile uint32_t ADC_ETC_Error = 0; // ADC_ETC Error counter
const uint8_t LED_PIN = 13;          // pin of onboard LED
volatile uint16_t LEDcounter = 0;

// FlexPWM programming variables and constants
int16_t TOP, HALF_TOP;                    // TOP and Top half of the counter range
volatile int16_t width_value;             // the integer value of half the pulse width to be loaded into the comparison registers
int16_t width_value_max, width_value_min; // limits for maximum and minimum pulse width (half the pulse width)

// Variables for calculating the sinusoidal signal in real time
volatile float phase; // phase of the sinusoidal signal
volatile float f;     // frequency of the sinusoidal signal
volatile float w;     // angular frequency of the sinusoidal signal
volatile float Vsin;  // amplitude of the sinusoidal signal
volatile float width; // pulse width of the sinusoidal signal proportional to the amplitude in half the timer count dimension.
volatile float ts;    // sampling period

volatile uint16_t k;  // sample counter
//buffers for sample storage
#define BUFFER_SIZE 800       // data buffer size 
float buffer_Va[BUFFER_SIZE]; // array to store samples of variable a
float buffer_Vb[BUFFER_SIZE]; // array to store samples of variable b
float buffer_Vc[BUFFER_SIZE]; // array to store samples of variable c
float buffer_Vd[BUFFER_SIZE]; // array to store samples of variable d

// - gain and offset to convert the digital sample into the value of the quantity in the unit specified in 
//   the multipoint external calibration process (not self-Calibration/internal to the ADC module)
// - as the sequence consists of 4 readings from the same channel, only the channel A0 was calibrated.
const float gain_a = 0.20296; 
const float gain_b = 0.20296;
const float gain_c = 0.20296;
const float gain_d = 0.20296;
const float offset_a = -409.173;
const float offset_b = -409.173;
const float offset_c = -409.173;
const float offset_d = -409.173;

// ==========================================================================================================
// ISR Function 1
void adc_etc_done0_isr() {
// - The interrupts done0, done1, and done2 ​​have distinct IRQs (118, 119, and 120). Up to 3 distinct 
//   triggers do not need to share the IRQ, and there is no need to check the call origin flag within the ISR.
// - In this example, only ADC_ETC_TRIGOO will be configured, with the DONE0 interrupt at the end of the sequence, 
//   eliminating the need to check the DONEx flag.

    if (k < BUFFER_SIZE) {    //Check that the buffers are not full.
        // Read the sequence result in the TRIG0 Result Registers
        uint32_t results = ADC_ETC_TRIG0_RESULT_1_0;  
        uint16_t sample_a = results & 0x0FFF;         // Lower 12 bits  -  chain 0
        uint16_t sample_b= (results >> 16) & 0x0FFF;  // Upper 12 bits  -  chain 1
        results = ADC_ETC_TRIG0_RESULT_3_2;
        uint16_t sample_c = results & 0x0FFF;         // Lower 12 bits  -  chain 2
        uint16_t sample_d= (results >> 16) & 0x0FFF;  // Upper 12 bits  -  chain 3   

        // Convert samples to volt
        buffer_Va[k] = gain_a * (float) sample_a + offset_a; 
        buffer_Vb[k] = gain_a * (float) sample_b + offset_a;
        buffer_Vc[k] = gain_a * (float) sample_c + offset_a;
        buffer_Vd[k] = gain_a * (float) sample_d + offset_a;              
        k++;
    }
  // generates a sinusoidal PWM wave - for demonstration purposes only, not necessary for ADC trigger generation
    phase = phase + w*ts;   //time integral of w
    if(phase >= TWO_PI) phase = phase - TWO_PI; // anti-windup
    Vsin= 0.9*sin(phase);  // calculation of the sinusoidal signal - the total amplitude must be less than 0.95 (width limitation)
    width =  Vsin*(float)HALF_TOP + (float)HALF_TOP;    // explore maximum amplitude and insert offset 
    width_value = (int16_t)width; //Convert pulse width to integer count value (timer in center-aligned pulse mode = half count)
    if (width_value > width_value_max) width_value = width_value_max; // maximum pulse saturation 
    if (width_value < width_value_min) width_value = width_value_min; // minimum pulse saturation 

    //Update VAL2, VAL3
    FLEXPWM4_SM2VAL2 = -width_value;      // PWM A (VAL2) goes High
    FLEXPWM4_SM2VAL3 =  width_value;      // PWM A (VAL3) goes Low
    //Considering INDEP = 0, (bit-13) of FLEXPWM4_SM2CTRL2, the PWMB will be a complementary signal of PWMA,
    // that is, 180 degrees out of phase, so it is not necessary to define VAL4 and VAL5 

    FLEXPWM4_MCTRL |= FLEXPWM_MCTRL_LDOK(1 << 2);  // Load ok for Submodule 2 - enable the update of compare registers at VAL0 or VAL1

    LEDcounter++;
    if(LEDcounter>= 12000 )   //change LED state each 0.5 seconds (interrupt frequency = 24kHz)
           {
             LEDcounter=0;
             digitalWriteFast(LED_PIN,!digitalReadFast(LED_PIN)); // blinks the onboard LED at 1Hz
           }

    // Clear the Done0 Interrupt Flag (Write 1 to Clear)
    ADC_ETC_DONE0_1_IRQ = ADC_ETC_DONE0_1_IRQ_TRIG_DONE0(0);

    asm volatile ("dsb");  // Data Synchronization Barrier -> This forces the CPU to wait until the peripheral really clears its interrupt flag,
                           //                                 It prevents the ISR from retriggering due to uncleared interrupt flags.
                           //                                 "volatile" -> Compiler must keep it exactly as written, do not move or remove it.
}

// ==========================================================================================================
// ISR Function 2
void adc_etc_error_isr() 
  {
    ADC_ETC_Error++; //To show that the error condition occurred in the main task

    ADC1_Clear_Coco(); //Clear ADC1 Conversion Complete Flags

    // Clear the Done0 Interrupt Flag (Write 1 to Clear)
    ADC_ETC_DONE2_ERR_IRQ = ADC_ETC_DONE2_ERR_IRQ_TRIG_ERR(0);

    asm volatile ("dsb");  // Data Synchronization Barrier -> This forces the CPU to wait until the peripheral really clears its interrupt flag,
                           //                                 It prevents the ISR from retriggering due to uncleared interrupt flags.
                           //                                 "volatile" -> Compiler must keep it exactly as written, do not move or remove it.
  }

// ==========================================================================================================
void setup() {
  // In spite of reset value shown in pag. 3200 of i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021.
  //  the code starts with the Flexpwm timers already in operation. Perhaps, during startup, 
  //  the Arduino code sets the RUN bit in the Master Control Register (MCTRL). It needs confirmation!.  
  FLEXPWM4_MCTRL &= ~FLEXPWM_MCTRL_RUN(1 << 2);   // Stop the counter in FLEXPWM4   
  FLEXPWM4_MCTRL &= ~FLEXPWM_MCTRL_CLDOK(1 << 2); // Clear Load OK for FLEXPWM4-SM2 (just in case...) 

  Serial.begin(115200);
  delay(1000);
  Serial.println("Teensy 4.1 Data Acquisition Test"); //welcome message

  // **** configure the GPIOs used ****
  digitalWriteFast(LED_PIN,LOW);  // set the desired state before activate the GPIO output
  pinMode(LED_PIN, OUTPUT);       // LED_PIN to output

  // Configure Pin Multiplexing for FlexPWM4-Submodule2 PWMA and PWMB to see the signals in oscilloscope 
  // Output 4A2 (Teensy 4.1 pin 2 - GPIO_EMC_04:ALT1) 
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 0x1;  // Set ALT1 for FlexPWM4 PWM4A2 
  // Output 4B2 (Teensy 4.1 pin 2 - GPIO_EMC_05:ALT1) 
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 0x1;  // Set ALT1 for FlexPWM4 PWM4B2 

  // According to the note in page 3407, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, The keeper causes an undesired jump behavior in ADC
  // To avoid the problem, disable keeper before starting ADC
  IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02 &= ~(1 << 12);  // Disable Keeper for A0 (GPIO_AD_B1_02) - ONLY THE CHANNEL A0 WILL BE USED IN THIS EXAMPLE

  // **** variable initialization ****
  TOP = 6250;              // FlexPWM4-SM2 freq_carrier=IPG_CLK/prescale/(2*TOP)= 150MHz/1/(2*6250) = 12kHz
  HALF_TOP = TOP >> 1;
  width_value = HALF_TOP;  // initial pulse width duty cycle(%)=(1/2*TOP-(-1/2*TOP))/( 2*TOP)*100
                           // initial pulse width duty cycle(%)=(  3125 -(  -3125 ))/(2*6250)*100 = 50%
  width_value_max = 5937;  // pulse width limitation: -> width_value max = 5937  - maximum pulse width ~= 95% (94.992%)
  width_value_min = 312;   //                         -> width_value min = 312  -  minimum pulse width ~= 05% (4.992%)

  f = 60.0f;          // fundamental frequency of the sinusoidal signal
  w = TWO_PI*f;       // fundamental angular frequency
  ts = 1.0f/24000.0f; // sampling period  (double sampling)

  k = BUFFER_SIZE; //an acquisition will begin when the sample counter is reset in the loop function.

  init_ADC1();
  Serial.println("ADC1 was configured!");
  ADC1_Calibrate(); //The subroutine sends the result of the internal calibration to the serial terminal before returning
  init_ADC_ETC();
  Serial.println("ADC_ETC was configured!");
  config_XBAR1();  // Route FlexPWM4_SM2_TRIG0 OR FLEXPWM4_PWM2_OUT_TRIG1 (XBAR1_IN54) to ADC_ETC_TRIG00 (XBAR1_OUT103)
  Serial.println("XBAR1 was configured!");
  init_flexpwm4_sm2();  //starts FlexPWM4-SM2
  Serial.println("FlexPWM4-SM2 was configured for ADC_ETC Trigger!");
  Serial.println("");
  Serial.println("Connect a low-pass filter as described in the header to output 4A2 (pin 2) and another to output 4B2 (pin 3) to view the sinusoidal signals in an oscilloscope.");
  Serial.println("Connect the sensor/signal conditioning circuit corresponding to the voltage to be measured to analog input A0 and then send the character '1' to acquire the voltage.");
  Serial.println("WARNING: The Teensy 4.1 pins are not 5V tolerant!");
  Serial.println("");
}

// ==========================================================================================================
void loop() {
  static uint16_t loop_counter=0; //to see that the code is running
  static uint32_t lastPrint = 0;  //for controlling the time interval of the periodic message via serial (millis() counter = 5s)

  // Check if at least one character has arrived
  if (Serial.available() > 0) {
    // Read the incoming byte
    char incomingChar = Serial.read();
    if(incomingChar == '1')  //start the acquisition if the received character is equal to '1'.
      {
        k=0;
        Serial.println("A series of acquisitions was initiated!");
        volatile uint8_t ADC1_timeout = 10; 
        while ((k < BUFFER_SIZE) && (ADC1_timeout > 0)) //Wait for the specified number of samples ~=1s
          {
           delay(100); // Wait 100ms 
           ADC1_timeout--;
          }
      if(ADC1_timeout == 0) Serial.println("Timeout in ADC_ETC sample chain!");
      else
          {
            Serial.println("Acquisition sequence completed");
            Serial.println("Acquisition Results:");
            Serial.println("Order     -     Va     -     Vb     -     Vc     -     Vd");
            for(uint16_t j=0;j< BUFFER_SIZE;j++)
               {
                Serial.print(j);
                Serial.print("   ");
                Serial.print(buffer_Va[j]);
                Serial.print("   "); 
                Serial.print(buffer_Vb[j]); 
                Serial.print("   ");
                Serial.print(buffer_Vc[j]);
                Serial.print("   "); 
                Serial.println(buffer_Vd[j]); 
              }
          }
      }
  }

  if(millis() - lastPrint > 5000)
  {
   lastPrint = millis();
   if(ADC_ETC_Error > 0)
       {
        Serial.print("ADC_ETC_Error - Number of errors detected: ");
        Serial.println(ADC_ETC_Error);  //it informs if there were errors in ADC_ECT
        ADC_ETC_Error = 0;
       }
   Serial.print(loop_counter);
   Serial.println("  - Waiting for command ('1') via Serial to acquire data sequence!");   
   loop_counter++;
  }

  delay(200);
}

// ==========================================================================================================
void init_flexpwm4_sm2() {
  // Enable Clock for FlexPWM1 using the macro defined in imxrt.h
  // iMXRT.h definitions: #define CCM_CCGR_OFF        0 ->  00 - Clock is off during all modes. Stop enter hardware handshake is disabled.
  //                      #define CCM_CCGR_ON_RUNONLY 1 ->  01 - Clock is on in run mode, but off in WAIT and STOP modes
  //                                                        10 - Not applicable (Reserved).
  //                      #define CCM_CCGR_ON         3 ->  11 - Clock is on during all modes, except STOP mode.
  CCM_CCGR4 |= CCM_CCGR4_PWM4(CCM_CCGR_ON);  // pwm4_clk_enable -> option 3: Clock is on during all modes, except STOP mode
  
  // Select clk source (EXT_CLK) 
  FLEXPWM4_SM2CTRL2 = FLEXPWM_SMCTRL2_CLK_SEL(0); // select clock source: CLK_SEL = 0b00 (IPG_CLK) 
                                                  //                                0b01 - EXT_CLK is used as the clock for the local prescaler and counter.
                                                  //                                0b10 - Submodule 0’s clock (AUX_CLK) is used as the source clock for the 
                                                  //                                       local prescaler and counter. This setting should not be used 
                                                  //                                       in submodule 0 as it will force the clock to logic 0.
                                                  //                                0b11 - reserved
  // allow updating of comparison registers and define prescaler 
  FLEXPWM4_SM2CTRL = FLEXPWM_SMCTRL_FULL   | //allow updating of comparison registers at the times corresponding to full-cycle  
                     FLEXPWM_SMCTRL_HALF   | //allow updating of comparison registers at the times corresponding to half-cycle  
                     FLEXPWM_SMCTRL_PRSC(0); // PRESCALE = 0b000 (Divide by 1) PWM clock frequency = f clk 
                                             // PRESCALE = 001b -  PWM clock frequency = f clk /2
                                             // PRESCALE = 010b -  PWM clock frequency = f clk /4
                                             // PRESCALE = 011b -  PWM clock frequency = f clk /8
                                             // PRESCALE = 100b -  PWM clock frequency = f clk /16
                                             // PRESCALE = 101b -  PWM clock frequency = f clk /32
                                             // PRESCALE = 110b -  PWM clock frequency = f clk /64
                                             // PRESCALE = 111b -  PWM clock frequency = f clk /128 
                                             // IMPORTANT: if FULL bit (VAL1) [or HALF bit (VAL0)] is reset, RF is not set when counter
                                             // reaches VAL1 and no FlexPWM interrupt is request. Its not the case here since FlexPWM interrupt will be not used,
                                             // but the bits FULL and HALF will be set only for sinusoidal signal generation in this example.

  //Define counter range and and pulse initial width for PWMA and PWMB
  FLEXPWM4_SM2INIT = -TOP;            // Carrier bottom
  FLEXPWM4_SM2VAL0 = 0;               // 
  FLEXPWM4_SM2VAL1 = TOP-1;           // Carrier TOP  => For TOP= 6250  => F_carrier = EXT_CLk/prescaler/counting steps => 150MHz/1/(2*6250)= 12kHz
  FLEXPWM4_SM2VAL2 = -width_value;    // PWM A (VAL2) goes High => initial pulse width duty cycle(%)=(1/2*TOP-(-1/2*TOP))/( 2*TOP)*100
  FLEXPWM4_SM2VAL3 =  width_value;    // PWM A (VAL3) goes Low  => initial pulse width duty cycle(%)=(   3125-(  -3125 ))/(2*6250)*100 = 50%
  // Considering INDEP = 0, (bit-13) of FLEXPWM4_SM2CTRL2, the PWMB will be a complementary signal of PWMA,
  //  that is, 180 degrees out of phase, so it is not necessary to define VAL4 and VAL5 

  // Output Enable (OUTEN): Enable outputs A and B for FlexPWM4 Submodule 2 - GPIO multiplexers were configured in setup
  FLEXPWM4_OUTEN = (FLEXPWM_OUTEN_PWMA_EN(1 << 2) | FLEXPWM_OUTEN_PWMB_EN(1 << 2)); 

  // Dead time configuration - number of IPBus clock cycles -> pag. 3170, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
  FLEXPWM4_SM2DTCNT0 = 50;  //deadtime during 0 to 1 transitions of the PWM_A output (assuming normal polarity) -> 50/150MHz=0.33us
  FLEXPWM4_SM2DTCNT1 = 50;  //deadtime during 0 to 1 transitions of the PWM_B output (assuming normal polarity)
  // In this example, the PWM signals will only be used to generate a sinusoidal signal via a low-pass filter. 
  // In the case of driving the gate of a power electronics converter, reconfigure the dead time to the value required for the application. 
  // It is usually safer to configure the dead time on the gate driver itself.

  // Output Polarity Control (OCTRL): Keep default polarity (low true)
  //FLEXPWM4_SM2OCTRL &= ~(FLEXPWM_SMOCTRL_POLA | FLEXPWM_SMOCTRL_POLB); ->pag. 3161, bit-10 POLA, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021

  //Complementary Pair Operation: keep default
  //FLEXPWM4_SM2CTRL2 &= ~FLEXPWM_SMCTRL2_INDEP; //->pag. 3144, bit-13 INDEP, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
  //FLEXPWM4_SM2CTRL2 |= FLEXPWM_SMCTRL2_INDEP;

  //Enable the FlexPWM4-SM2 trigger0 and trigger 1 output for ADC triggering via XBAR (Double Sampling)
  FLEXPWM4_SM2TCTRL |= FLEXPWM_SMTCTRL_OUT_TRIG_EN(1 << 0) |  // Trigger 0 enable - PWM_OUT_TRIG0 will set when the counter value matches the VAL0 value.
                       FLEXPWM_SMTCTRL_OUT_TRIG_EN(1 << 1) ;  // Trigger 1 enable - PWM_OUT_TRIG1 will set when the counter value matches the VAL1 value.

  // Start the FlexPWM4 submodule2
  FLEXPWM4_MCTRL |= FLEXPWM_MCTRL_CLDOK(1 << 2); // Clear Load OK for Submodule 2 (just in case...)
  FLEXPWM4_MCTRL |= FLEXPWM_MCTRL_LDOK(1 << 2);  // Set Load OK for Submodule 2 (loads initial VALs)
  FLEXPWM4_MCTRL |= FLEXPWM_MCTRL_RUN(1 << 2);   // Start the counter for Submodule 2
}

// ==========================================================================================================
void init_ADC1(void) {
   // Enable Clock for ADC1 using the macro defined in imxrt.h
  CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON); // Enable ADC1 Clock -> Bits:17–16 CG8, page 1079, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
  //Even when using the Asynchronous Clock Source as ADC Conversion Clock, it is necessary to enable the clock for the ADC in the Clock Control Module (CCM),
  // because the operation of the peripheral interface (the registers you read and write) is still clocked by the system bus clock (IPG clock).

  // **** Select ADC Conversion Clock ****
  //  Notes:
  //  -> In page 65, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors, it is said that the operating frequency
  //     of the ADC module can vary from a minimum of 4 MHz to a maximum of 40 MHz (ADLPC=0, not in low power mode; ADHSC=1, High speed conversion).
  //  -> It is important to keep in mind that there is a relationship between the operating frequency of the ADC and its accuracy, with greater accuracy 
  //     occurring at lower frequencies.
  //  -> Increasing the operating frequency allows for operation at higher sampling rates at the cost of reduced accuracy. This results in a trade-off
  //     that must be adjusted according to the application.
  //  -> ADC Conversion Clock Options (ADICLK): 00 IPG clock
  //                                            01 IPG clock divided by 2
  //                                            10 Reserved
  //                                            11 Asynchronous clock (ADACK)* 
  // * ADC Asynchronous Clock Source: (page 66, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors) 
  //   ADHSC=0 -> fADACK = 10 MHz 
  //   ADHSC=1 -> fADACK = 20 MHz

  //  => Change the ADC clock according your application
  //  => IN THIS EXAMPLE, Asynchronous clock (ADACK) will be used, which is a dedicated clock used only by the ADC (20MHz - Divider 1, ADHSC=1 ).
#define ADC_CLOCK_SOURCE 1  // 0: IPG/2/4 (18.75 MHz) | 1: ADACK (20MHz)   

  ADC1_CFG &= ~(ADC_CFG_ADICLK(3));  // Clear ADICLK (00-> IPG CLK)
  ADC1_CFG &= ~(ADC_CFG_ADIV(3));    // Clear ADIV   (00-> divider=1)

#if (ADC_CLOCK_SOURCE == 0)          // Option 0: IPG/2
    //the lines below configure ADC Conversion Clk for  18.75 MHz, based on IPG CLK  =>  150MHz/2/4 = 18.75 MHz
  ADC1_CFG |= ADC_CFG_ADICLK(1);     // ADICLK = 01
  ADC1_CFG |= ADC_CFG_ADIV(2);       // ADIV = 10 (Div by 4)
    
#elif (ADC_CLOCK_SOURCE == 1)        // Option 1: ADACK
  ADC1_GC  |= ADC_GC_ADACKEN;        // Enable the oscillator (ADACKEN) -> Force ADACK oscillator to run continuously (Higher Power Consumption)
                                     //  to reduce the latency of initiating a single or first-continuous conversion
  ADC1_CFG |= ADC_CFG_ADICLK(3);     // ADICLK = 11
  #else
    #error "Invalid ADC_CLOCK_SOURCE selected!"
#endif

  //For a shorter sampling time, use LPC=0 and HSC=1. See page 68, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors.
  ADC1_CFG |= ADC_CFG_ADHSC;       // Select high speed conversion (HSC=1)
  ADC1_CFG &= ~(ADC_CFG_ADLPC);    // ADC hard block not in low power mode (LPC=0)

  ADC1_CFG &= ~(ADC_CFG_MODE(3));  // Clear MODE
  ADC1_CFG |= ADC_CFG_MODE(2);     // MODE = 0b10 -> 12-bit conversion

  // Sample time configuration
  ADC1_CFG &= ~(ADC_CFG_ADLSMP);   // LSMP=0 -> Short sample mode
  ADC1_CFG &= ~(ADC_CFG_ADSTS(3)); // Clear STS
  ADC1_CFG |= ADC_CFG_ADSTS(2);    // Set STS=0b10 => Sample period (ADC clocks) = 7 if ADLSMP=0b => 1/20MHz*7= 350ns

  ADC1_CFG |= ADC_CFG_ADTRG;       // Selects Hardware trigger - The ADC_ETC module will be configured to trigger the ADC.
  ADC1_GC &= ~(ADC_GC_ADCO);       // Ensures that the ADC waits for the ADC_ETC trigger (not in continuous conversion mode)

  ADC1_GC &= ~(ADC_GC_AVGE);       // Hardware Average disabled => If Enabled -> configure the number of samples below
  // ADC1_CFG &= ~(ADC_CFG_AVGS(3));  // Clear AVGS  
  // ADC1_CFG |= ADC_CFG_AVGS(2);     // Set AVGS: 0b00 - 4 samples averaged; 0b01 - 8 samples averaged; 0b10 - 16 samples averaged; 0b11 32 samples averaged 

  ADC1_HC0 = 16; // The ADC_ETC will be used to select the channel on trigger0 (slot 0) of ADC1.
                 // See page 3431, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors 
  ADC1_HC1 = 16; // Configure ADCx_HCn for all slots used by ADC_ETC
  ADC1_HC2 = 16;
  ADC1_HC3 = 16;  

  //Note: Other parameters must be in accordance with the reset condition. If the ADC exhibits improper operation, check the additional configuration
  //      bits in the manual.      
}

// ==========================================================================================================
void ADC1_Calibrate(void) {
  // According to the i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors, page 3419, the ADC must be calibrated
  // using the exact settings you intend to use in your end application (ADC's clock source and frequency, low power configuration, voltage reference selection,
  // sample time, averaging, and the high speed); therefore, configure the ADC before calling this subroutine.

  uint32_t ADC1_config = ADC1_CFG; //save ADC1 hardware trigger option
  ADC1_CFG &= ~ADC_CFG_ADTRG;      //reset hardware trigger for calibration process,  page 3419, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021 

  //  Start Calibration
  ADC1_GC |= ADC_GC_CAL;

  //  Timeout Loop (10ms max)
  volatile uint8_t timeout = 10; 
  while ((ADC1_GC & ADC_GC_CAL) && (timeout > 0)) {
        delay(1); // Wait 1ms 
        timeout--;
  }

  // Calibration Result
  if (timeout == 0)
        {
          Serial.println("Timeout in the ADC1 calibration process!");
        } 
  else if (ADC1_GS & ADC_GS_CALF)   // Check CAL flag
             {
               Serial.println("The ADC1 calibration process failed!");
               ADC1_GS |= ADC_GS_CALF; // Clear the fail flag
             }
       else
             {
               uint32_t cal_code = (ADC1_CAL & 0x0F);
               Serial.println("The ADC1 calibration process was was completed successfully!");
               Serial.print("CAL_CODE = ");
               Serial.println(cal_code);
             }
  ADC1_CFG =  ADC1_config; //restore ADC1 hardware trigger option          
}

// ==========================================================================================================
void init_ADC_ETC(void) {
  // Using this routine implies that:
  //  - The ADC1 module has been configured for Hardware Triggering;
  //  - ADCH = 0b10000 in ADC_HCn register for external channel selection from ADC_ETC (applied to used triggers)
  //  - The ADC_ETC_TRIG00 signal will be activated, therefore configure an appropriate trigger signal on the XBAR1 module.

  ADC_ETC_CTRL |= ADC_ETC_CTRL_SOFTRST; // software reset
  asm volatile("dsb"); // wait for set SOFTRST bit
  delay(10);           // wait for reset process
  ADC_ETC_CTRL &= ~ADC_ETC_CTRL_SOFTRST;// normal operation
  asm volatile("dsb"); // wait for reset SOFTRST bit
  delay(10);           // wait for normal operation starts  

   ADC1_Clear_Coco(); //Clear ADC1 Conversion Complete Flags - This is a kind of reset of ADC1 (just in case...)                      
 
  // Trigger 0 Chain with 4 segments (4 channel to sample) (N+1)
  // SYNC_MODE is 0 because we are only using ADC1 sequentially 
  // Priority does not matter, no other trigger to compete for the ADC's attention.
  // Select Hardware trigger mode
  ADC_ETC_TRIG0_CTRL = ADC_ETC_TRIG_CTRL_TRIG_CHAIN(3); // "3" means 4 items (N+1)
 
  // Configure Trigger 0 Chain
  // Segment 0: ADC1 (HWTS 0), Channel 7 (A0), No Interrupt  
  // Segment 1: ADC1 (HWTS 1), Channel 7 (A0), No Interrupt
  // Segment 2: ADC1 (HWTS 2), Channel 7 (A0), No Interrupt
  // Segment 3: ADC1 (HWTS 3), Channel 7 (A0), Interrupt Enabled (IE=01)
  // Interrupt configuration:  00b-No interrupt; 01b-interrupt on Done0; 10b-interrupt on Done1; 11b-interrupt on Done2 
  // It was specified the same channel to reduce the lab resources in the test
  ADC_ETC_TRIG0_CHAIN_1_0 = 
       ADC_ETC_TRIG_CHAIN_B2B0           |    // Back to Back ADC trigger (B2B) is not applied, B2B doesn't matter here because since this is the first conversion
       ADC_ETC_TRIG_CHAIN_HWTS0(1 << 0)  |    // LOWER WORD: Target ADC1 Slot 0 (HC0) for first sample**
       ADC_ETC_TRIG_CHAIN_CSEL0(A0)      |    //             Sample A0 (Hardware Channel 7)
       ADC_ETC_TRIG_CHAIN_IE0(0)         |    //             No interrupt after first sample

       ADC_ETC_TRIG_CHAIN_B2B1           |    // Start this second conversion immediately after adc_coco (conversion complete flag) from first conversion
       ADC_ETC_TRIG_CHAIN_HWTS1(1 << 1)  |    // UPPER WORD: Target ADC1 Slot 1 (HC1) for second sample**
       ADC_ETC_TRIG_CHAIN_CSEL1(A0)      |    //             Sample A0 (Hardware Channel 7)  
       ADC_ETC_TRIG_CHAIN_IE1(0)         ;    //             No interrupt after second sample

  ADC_ETC_TRIG0_CHAIN_3_2 = 
       ADC_ETC_TRIG_CHAIN_B2B0           |    // Start this third conversion immediately after adc_coco (conversion complete flag) from second conversion
       ADC_ETC_TRIG_CHAIN_HWTS0(1 << 2)  |    // LOWER WORD: Target ADC1 Slot 2 (HC2) for third sample**
       ADC_ETC_TRIG_CHAIN_CSEL0(A0)      |    //             Sample A0 (Hardware Channel 7)
       ADC_ETC_TRIG_CHAIN_IE0(0)         |    //              No interrupt after third sample 

       ADC_ETC_TRIG_CHAIN_B2B1           |    // Start this fourth conversion immediately after adc_coco (conversion complete flag) from third conversion
       ADC_ETC_TRIG_CHAIN_HWTS1(1 << 3)  |    // LOWER WORD: Target ADC1 Slot 3 (HC3) for fourth sample**
       ADC_ETC_TRIG_CHAIN_CSEL1(A0)      |    //             Sample A0 (Hardware Channel 7)
       ADC_ETC_TRIG_CHAIN_IE1(1)         ;    //    Interrupt (Done0) at the end of fourth sample 
  //** Different slots (HWTS) have been specified here, but the same slot as before can be reused. Remember to set ADCxHCn=0x10

// IMPORTANT NOTE: If B2B is set for all segments of the chain above (except the first), there is no need to configure the sampling interval. 
//                 If B2B = 0 for any segment other than the first, the sampling interval must be adjusted to a delay greater than the total
//                  sampling time (sampling time + conversion time). In this example, the choice was made to set B2B.
//ADC_ETC_CTRL |= ADC_ETC_CTRL_PRE_DIVIDER(1);   // configure pre_divider = 1 (8-bits) for initial delay and sample interval
//ADC_ETC_TRIG0_COUNTER =   ADC_ETC_TRIG_COUNTER_INIT_DELAY(0) |       // Initial_delay (16-bits) = (INIT_DELAY+1)*(PRE_DIVIDER+1)*ipg_clk
//                          ADC_ETC_TRIG_COUNTER_SAMPLE_INTERVAL(136); // Interval_delay = (SAMPLE_INTERVAL+1)*(PRE_DIVIDER+1)*ipg_clk

  // Install the ISR to IRQ 118 (Done0)
  attachInterruptVector(IRQ_ADC_ETC0, &adc_etc_done0_isr); 
  // Set priority (optional, 128 is default)
  NVIC_SET_PRIORITY(IRQ_ADC_ETC0, 0x80);  // Only the superior nibble is considered => 128=0x80= 1000 0000 => Level 8 out of 15 (16 levels)
    // Enable the IRQ in the Nested Vectored Interrupt Controller
  NVIC_ENABLE_IRQ(IRQ_ADC_ETC0); // Enable the IRQ in NVIC (Nested Vectored Interrupt Controller) => Interrupt at ADC_ETC was enabled above
  
  // Install the ISR to IRQ 121 (TRIG0_ERR)
  attachInterruptVector(IRQ_ADC_ETC_ERR, &adc_etc_error_isr);
  // Set priority (optional)
  NVIC_SET_PRIORITY(IRQ_ADC_ETC_ERR, 0x90);  // Only the superior nibble is considered => 0x70= 0111 0000 => Level 7 out of 15 (16 levels)
  // Enable the IRQ in the Nested Vectored Interrupt Controller
  NVIC_ENABLE_IRQ(IRQ_ADC_ETC_ERR);

  // Configure ADC_ETC Global Control - Enable trigger 0
  ADC_ETC_CTRL |= ADC_ETC_CTRL_TRIG_ENABLE(1 << 0); //Only TRIG00 is enabled:  0x10 - TRIG10; 0x01 - TRIG00  => 0xFF enable all 8 triggers
                                                    //                         0x20 - TRIG11; 0x02 - TRIG01
                                                    //                         0x40 - TRIG12; 0x04 - TRIG02
                                                    //                         0x80 - TRIG13; 0x08 - TRIG03

  //Notes: - Other parameters must be in accordance with the reset condition. 
  //       - TRIGGER sampling interval and initial delay in default values (ETC_TRIG Counter Register)
}

// ==========================================================================================================
void config_XBAR1(void){
  // ===== XBAR1 Configuration =====
  CCM_CCGR2 |= CCM_CCGR2_XBAR1(CCM_CCGR_ON); // Enable Clock for XBARA1
  // Route FlexPWM4_SM2_TRIG0 OR FLEXPWM4_PWM2_OUT_TRIG1 (XBAR1_IN54) to ADC_ETC_TRIG00 (XBAR1_OUT103)
  // Note that FLEXPWM4_PWM2_OUT_TRIG0 and FLEXPWM4_PWM2_OUT_TRIG1 share the XBAR1_IN54 input through a logical OR operation.
  // XBARA1_SEL51 handles Output 102 (bits 6:0) and Output 103 (bits 14:8) => number of input in 7-bits
  XBARA1_SEL51 &= ~0x7F00;    // Clear SEL103 (XBAR1_OUT103)
  XBARA1_SEL51 |= (54 << 8);  // Set XBAR1_OUT103 to XBAR1_IN54, note that the configuration of interest is in the upper byte (bits 14-8)
  // => IMPORTANT NOTE: In i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, Table 4-5. - XBAR1 Input Assignments, page 62, FlexPWM4_SM2_TRIG0 and 
  //    FLEXPWM4_PWM2_OUT_TRIG1 are assigned to XBAR1_IN53, I think this is a mistake, since the current code is working!  
}

// ==========================================================================================================
void ADC1_Clear_Coco(void) //Clear ADC1 Conversion Complete Flags
{
    //Reset COCO flags - page 3412, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
    volatile uint32_t dummy; 
    dummy = ADC1_R0;
    dummy = ADC1_R1;
    dummy = ADC1_R2;
    dummy = ADC1_R3;
    dummy = ADC1_R4;
    dummy = ADC1_R5;
    dummy = ADC1_R6;
    dummy = ADC1_R7; 
}
// ==========================================================================================================

