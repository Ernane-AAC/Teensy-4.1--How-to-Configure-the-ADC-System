// ========================================================================================
// Data acquisition on the Teensy 4.1 ADC1
// UNVERSIDADE FEDERAL DE UBERLÂNDIA - Faculdade de Engenharia Elétrica
// Subject: DSP-EPS - Prof. Ernane A. A. Coelho - http://lattes.cnpq.br/9183492978798433
// This code is for demonstration purposes only, showing how to perform data acquisition using the Teensy 4.1 ADC1 and ADC2 
// in Sync Mode hardware trigger.
// Code characteristics:
// - Data acquisition is performed via channel A0 of ADC1 and channel A1 of ADC2 of the Teensy 4.1.
// - A voltage sensor based on a differential amplifier will be connected to channel A0 (ADC1) and 
//   a Hall effect current sensor (ACS758LCB-050B) will be connected to channel A1 (ADC2).
// - The acquisition sequence for each ADC will consist of only 1 channel, operating in synchronous mode, 
//   meaning that voltage (A0-ADC1) and current (A1-ADC2) samples will be acquired simultaneously.
// - The ADC_ETC trigger will be generated by submodule 2 of FlexPWM 4.
// - The carrier frequency of the FlexPWM4SM2 will be 12kHz. Trigger0 (half-cycle) and trigger1 (full-cycle) will be used, 
//   implying double sampling per PWM cycle, generating a sampling frequency of 24kHz.
// - In this code version, the timer in submodule 2 of FlexPWM4 will only be used to generate the trigger signal (sampling rate),
//   and no PWM signal will be generated.
// - Data acquisition will be performed when the operator sends the character "1" via serial. The loop function checks the received characters, 
//   executes the acquisition if the character is equal to "1", converts the samples to the specified unit and sends the acquisition results back via serial.
// ========================================================================================
#include "Arduino.h"
#include <imxrt.h>
#include <math.h>

//Teensy 4.1 Analog Inputs:
//Teensy Analog Input | Teensy Pin | iMXRT1062 pad | ADC1 IN | ADC2 IN |
#define A0 7      //  |      14    |    AD_B1_02   |   IN7   |   IN7   |
#define A1 8      //  |      15    |    AD_B1_03   |   IN8   |   IN8   |
#define A2 12     //  |      16    |    AD_B1_07   |   IN12  |   IN12  |
#define A3 11     //  |      17    |    AD_B1_06   |   IN11  |   IN11  |
#define A4 6      //  |      18    |    AD_B1_01   |   IN6   |   IN6   |
#define A5 5      //  |      19    |    AD_B1_00   |   IN5   |   IN5   |
#define A6 15     //  |      20    |    AD_B1_10   |   IN15  |   IN15  |
#define A7 0      //  |      21    |    AD_B1_11   |   IN0   |   IN0   |
// - For other channels, see the Teensy 4.1 documentation and Table 66-2, ADC external signals, page 3405,
//   i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors.

volatile uint32_t ADC_ETC_Error = 0; // ADC_ETC Error counter
volatile uint32_t ADC_Timeout   = 0; // ADC_Timeout counter
const uint8_t LED_PIN = 13;          // pin of onboard LED
volatile uint16_t LEDcounter = 0;    // To control the LED blinking at 1Hz

// FlexPWM programming variable
int16_t TOP;                   // TOP of the counter range

volatile uint16_t k;  // sample counter
//buffers for sample storage
#define BUFFER_SIZE 1600       // data buffer size 
float buffer_Va[BUFFER_SIZE];  // array to store voltage samples 
float buffer_Ia[BUFFER_SIZE];  // array to store current samples 

// =>gain and offset to convert the digital sample into the value of the quantity in the unit specified in 
//   the multipoint external calibration process (not self-Calibration/internal to the ADC module)
//   gain and offset to convert the digital sample to Volt
const float gain_V = 0.19855;
const float offset_V = -409.0648;
//   gain and offset to convert the digital sample to Ampere
const float gain_I = 0.031565;
const float offset_I = -64.993;

// ==========================================================================================================
// ISR Function 1
void adc_etc_done0_isr() {
// - The interrupts done0, done1, and done2 ​​have distinct IRQs (118, 119, and 120). Up to 3 distinct 
//   triggers do not need to share the IRQ, and there is no need to check the call origin flag within the ISR.
// - In this example, only ADC_ETC_TRIGOO will be configured, however, the sync mode implies that ADC_ETC_TRIGOO will
//   generate trigger 0 for ADC1 and trigger 4 for ADC2, simultaneously, which will request the done0 interrupt 
//   at the end of the conversion. Since ADC1 and ADC2 units are independent, there is no guarantee that the conversion 
//   time will be exactly the same. Therefore, when entering the ISR requested by the faster unit, the other may not be
//   ready for the conversion result to be read. There is no specific information about this in the i.MX RT1060 Processor
//   Reference Manual, Rev. 3, 07/2021. Thus, both flags will be checked before reading data.

  //  checks if both ADC1 and ADC2 units are ready - timeout control prevents infinite loop if an ADC unit fails
    const uint32_t both_done = 0x11;  //0x11 = ADC_ETC_DONE0_1_IRQ_TRIG_DONE0(4) |ADC_ETC_DONE0_1_IRQ_TRIG_DONE0(0);
    volatile uint8_t timeout = 2000; 
    while (((ADC_ETC_DONE0_1_IRQ & both_done) != both_done) && (timeout > 0))  
      { 
        timeout--;
      }
    if (timeout == 0) ADC_Timeout++; //To show that the timeout condition occurred in the main task

    if (k < BUFFER_SIZE) {    //Check that the buffers are not full.
        // Read the sequence result in the TRIG0 Result Registers
        uint32_t results = ADC_ETC_TRIG0_RESULT_1_0;  
        uint16_t sample_a = results & 0x0FFF;         // Lower 12 bits  -  chain 0
        // Read the sequence result in the TRIG4 Result Registers
        results = ADC_ETC_TRIG4_RESULT_1_0;
        uint16_t sample_b = results & 0x0FFF;         // Lower 12 bits  -  chain 0

        buffer_Va[k] = gain_V * (float) sample_a + offset_V; // Convert sample to Volt   and save it
        buffer_Ia[k] = gain_I * (float) sample_b + offset_I; // Convert sample to Ampere and save it            
        k++;
    }

    LEDcounter++;
    if(LEDcounter>= 12000 )   //change LED state each 0.5 seconds (interrupt frequency = 24kHz)
           {
             LEDcounter=0;
             digitalWriteFast(LED_PIN,!digitalReadFast(LED_PIN)); // blinks the onboard LED at 1Hz
           }

    // Clear the Done0 Interrupt Flag for trigger 0 and trigger 4 (Write 1 to Clear)
    ADC_ETC_DONE0_1_IRQ = ADC_ETC_DONE0_1_IRQ_TRIG_DONE0(4) |
                          ADC_ETC_DONE0_1_IRQ_TRIG_DONE0(0);

    asm volatile ("dsb");  // Data Synchronization Barrier -> This forces the CPU to wait until the peripheral really clears its interrupt flag,
                           //                                 It prevents the ISR from retriggering due to uncleared interrupt flags.
                           //                                 "volatile" -> Compiler must keep it exactly as written, do not move or remove it.
}

// ==========================================================================================================
// ISR Function 2
void adc_etc_error_isr() 
  {
    ADC_ETC_Error++; //To show that the error condition occurred in the main task

    //Regardless of which trigger (0 or 4) requested the ERR interrupt, this code will clear the coco flags from ADC1 and ADC2. 
    ADC1_Clear_Coco(); //Clear ADC1 Conversion Complete Flags
    ADC2_Clear_Coco(); //Clear ADC2 Conversion Complete Flags

    // Clear the Trigger 0 and Trigger 4 ERR Interrupt Flag (Write 1 to Clear)
    ADC_ETC_DONE2_ERR_IRQ = ADC_ETC_DONE2_ERR_IRQ_TRIG_ERR(4)|
                            ADC_ETC_DONE2_ERR_IRQ_TRIG_ERR(0);

    asm volatile ("dsb");  // Data Synchronization Barrier -> This forces the CPU to wait until the peripheral really clears its interrupt flag,
                           //                                 It prevents the ISR from retriggering due to uncleared interrupt flags.
                           //                                 "volatile" -> Compiler must keep it exactly as written, do not move or remove it.
  }

// ==========================================================================================================
void setup() {
  // In spite of reset value shown in pag. 3200 of i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021.
  //  the code starts with the Flexpwm timers already in operation. Perhaps, during startup, 
  //  the Arduino code sets the RUN bit in the Master Control Register (MCTRL). It needs confirmation!.  
  FLEXPWM4_MCTRL &= ~FLEXPWM_MCTRL_RUN(1 << 2);   // Stop the counter in FLEXPWM4   
  FLEXPWM4_MCTRL &= ~FLEXPWM_MCTRL_CLDOK(1 << 2); // Clear Load OK for FLEXPWM4-SM2 (just in case...) 

  Serial.begin(115200);
  delay(1000);
  Serial.println("Teensy 4.1 Synchronized Data Acquisition Test"); //welcome message

  // **** configure the GPIOs used ****
  digitalWriteFast(LED_PIN,LOW);  // set the desired state before activate the GPIO output
  pinMode(LED_PIN, OUTPUT);       // LED_PIN to output

  // According to the note in page 3407, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, The keeper causes an undesired jump behavior in ADC
  // To avoid the problem, disable keeper before starting ADC
  IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02 &= ~(1 << 12);  // Disable Keeper for A0 (GPIO_AD_B1_02) - THE CHANNEL A0 WILL BE USED IN THIS EXAMPLE
  IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03 &= ~(1 << 12);  // Disable Keeper for A1 (GPIO_AD_B1_03) - THE CHANNEL A1 WILL BE USED IN THIS EXAMPLE

  // **** variable initialization ****
  TOP = 6250;              // FlexPWM4-SM2 freq_carrier=IPG_CLK/prescale/(2*TOP)= 150MHz/1/(2*6250) = 12kHz
  k = BUFFER_SIZE;         // an acquisition will begin when the sample counter is reset in the loop function.

  init_ADC1();
  Serial.println("ADC1 was configured!");
  ADC1_Calibrate(); //The subroutine sends the result of the internal calibration to the serial terminal before returning
  init_ADC2();
  Serial.println("ADC2 was configured!");
  ADC2_Calibrate(); //The subroutine sends the result of the internal calibration to the serial terminal before returning

  init_ADC_ETC();
  Serial.println("ADC_ETC was configured!");
  config_XBAR1();  // Route FlexPWM4_SM2_TRIG0 OR FLEXPWM4_PWM2_OUT_TRIG1 (XBAR1_IN54) to ADC_ETC_TRIG00 (XBAR1_OUT103)
  Serial.println("XBAR1 was configured!");
  init_flexpwm4_sm2();  //starts FlexPWM4-SM2
  Serial.println("FlexPWM4-SM2 was configured for ADC_ETC Trigger!");
  Serial.println("");
  Serial.println("Connect the sensor/signal conditioning circuit corresponding to the voltage to be measured to analog input A0");
  Serial.println("Connect the sensor/signal conditioning circuit corresponding to the current to be measured to analog input A1");
  Serial.println("Send the character '1' via serial terminal to acquire the voltage and current.");
  Serial.println("WARNING: The Teensy 4.1 pins are not 5V tolerant!");
  Serial.println("");

}

// ==========================================================================================================
void loop() {
  static uint16_t loop_counter=0; //to see that the code is running
  static uint32_t lastPrint = 0;  //for controlling the time interval of the periodic message via serial (millis() counter = 5s)

  // Check if at least one character has arrived
  if (Serial.available() > 0) {
    // Read the incoming byte
    char incomingChar = Serial.read();
    if(incomingChar == '1')  //start the acquisition if the received character is equal to '1'.
      {
        k=0;
        Serial.println("A series of acquisitions was initiated!");
        volatile uint8_t ADC_ETC_timeout = 10; 
        while ((k < BUFFER_SIZE) && (ADC_ETC_timeout > 0)) //Wait for the specified number of samples ~=1s
          {
           delay(100); // Wait 100ms 
           ADC_ETC_timeout--;
          }
      if(ADC_ETC_timeout == 0) Serial.println("Timeout in ADC_ETC sample chain!");
      else
          {
            Serial.println("Acquisition sequence completed");
            Serial.println("Acquisition Results:");
            Serial.println("Order  -  Voltage (V)  -  Current (A) ");
            for(uint16_t j=0;j< BUFFER_SIZE;j++)
               {
                Serial.print(j);
                Serial.print("   ");
                Serial.print(buffer_Va[j]);
                Serial.print("   "); 
                Serial.println(buffer_Ia[j]); 
              }
          }
      }
  }

  if(millis() - lastPrint > 5000)
  {
   lastPrint = millis();
   if(ADC_ETC_Error > 0)
       {
        Serial.print("ADC_ETC_Error - Number of errors detected: ");
        Serial.println(ADC_ETC_Error);  //it informs if there were errors in ADC_ECT
        ADC_ETC_Error = 0;
       }
   if(ADC_Timeout > 0)
       {
        Serial.print("Timeout expired when ISR was waiting for ADC1 or ADC2 to read! Number of errors detected: ");
        Serial.println(ADC_Timeout);  //it informs if there were timeout in ADC1 or ADC2
        ADC_Timeout = 0;
       }       
   Serial.print(loop_counter);
   Serial.println("  - Waiting for command ('1') via Serial to acquire data sequence!");   
   loop_counter++;
  }

  delay(200);
}

// ==========================================================================================================
void init_flexpwm4_sm2() {
  // Enable Clock for FlexPWM1 using the macro defined in imxrt.h
  // iMXRT.h definitions: #define CCM_CCGR_OFF        0 ->  00 - Clock is off during all modes. Stop enter hardware handshake is disabled.
  //                      #define CCM_CCGR_ON_RUNONLY 1 ->  01 - Clock is on in run mode, but off in WAIT and STOP modes
  //                                                        10 - Not applicable (Reserved).
  //                      #define CCM_CCGR_ON         3 ->  11 - Clock is on during all modes, except STOP mode.
  CCM_CCGR4 |= CCM_CCGR4_PWM4(CCM_CCGR_ON);  // pwm4_clk_enable -> option 3: Clock is on during all modes, except STOP mode
  
  // Select clk source (EXT_CLK) 
  FLEXPWM4_SM2CTRL2 = FLEXPWM_SMCTRL2_CLK_SEL(0); // select clock source: CLK_SEL = 0b00 (IPG_CLK) 
                                                  //                                0b01 - EXT_CLK is used as the clock for the local prescaler and counter.
                                                  //                                0b10 - Submodule 0’s clock (AUX_CLK) is used as the source clock for the 
                                                  //                                       local prescaler and counter. This setting should not be used 
                                                  //                                       in submodule 0 as it will force the clock to logic 0.
                                                  //                                0b11 - reserved
  // define prescaler 
  FLEXPWM4_SM2CTRL = FLEXPWM_SMCTRL_PRSC(0); // PRESCALE = 0b000 (Divide by 1) PWM clock frequency = f clk 
                                             // PRESCALE = 001b -  PWM clock frequency = f clk /2
                                             // PRESCALE = 010b -  PWM clock frequency = f clk /4
                                             // PRESCALE = 011b -  PWM clock frequency = f clk /8
                                             // PRESCALE = 100b -  PWM clock frequency = f clk /16
                                             // PRESCALE = 101b -  PWM clock frequency = f clk /32
                                             // PRESCALE = 110b -  PWM clock frequency = f clk /64
                                             // PRESCALE = 111b -  PWM clock frequency = f clk /128 
                                             // IMPORTANT: if FULL bit (VAL1) [or HALF bit (VAL0)] is reset, RF is not set when counter
                                             // reaches VAL1 and no FlexPWM interrupt is request. Its not the case here since FlexPWM interrupt will be not used,
                                             // but the bits FULL and HALF will be set only for sinusoidal signal generation in this example.

  //Define counter range and and pulse initial width for PWMA and PWMB
  FLEXPWM4_SM2INIT = -TOP;            // Carrier bottom
  FLEXPWM4_SM2VAL0 = 0;               // 
  FLEXPWM4_SM2VAL1 = TOP-1;           // Carrier TOP  => For TOP= 6250  => F_carrier = EXT_CLk/prescaler/counting steps => 150MHz/1/(2*6250)= 12kHz

  //The FlexPWM4SM2 will only be used to trigger the ADC_ETC; no PWM outputs will be utilized.

  //Enable the FlexPWM4-SM2 trigger0 and trigger 1 output for ADC triggering via XBAR (Double Sampling = 24kHz)
  FLEXPWM4_SM2TCTRL |= FLEXPWM_SMTCTRL_OUT_TRIG_EN(1 << 0) |  // Trigger 0 enable - PWM_OUT_TRIG0 will set when the counter value matches the VAL0 value.
                       FLEXPWM_SMTCTRL_OUT_TRIG_EN(1 << 1) ;  // Trigger 1 enable - PWM_OUT_TRIG1 will set when the counter value matches the VAL1 value.

  // Start the FlexPWM4 submodule2
  FLEXPWM4_MCTRL |= FLEXPWM_MCTRL_CLDOK(1 << 2); // Clear Load OK for Submodule 2 (just in case...)
  FLEXPWM4_MCTRL |= FLEXPWM_MCTRL_LDOK(1 << 2);  // Set Load OK for Submodule 2 (loads initial VALs)
  FLEXPWM4_MCTRL |= FLEXPWM_MCTRL_RUN(1 << 2);   // Start the counter for Submodule 2
}

// ==========================================================================================================
void init_ADC1(void) {
   // Enable Clock for ADC1 using the macro defined in imxrt.h
  CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON); // Enable ADC1 Clock -> Bits:17–16 CG8, page 1079, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
  //Even when using the Asynchronous Clock Source as ADC Conversion Clock, it is necessary to enable the clock for the ADC in the Clock Control Module (CCM),
  // because the operation of the peripheral interface (the registers you read and write) is still clocked by the system bus clock (IPG clock).

  // **** Select ADC Conversion Clock ****
  //  Notes:
  //  -> In page 65, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors, it is said that the operating frequency
  //     of the ADC module can vary from a minimum of 4 MHz to a maximum of 40 MHz (ADLPC=0, not in low power mode; ADHSC=1, High speed conversion).
  //  -> It is important to keep in mind that there is a relationship between the operating frequency of the ADC and its accuracy, with greater accuracy 
  //     occurring at lower frequencies.
  //  -> Increasing the operating frequency allows for operation at higher sampling rates at the cost of reduced accuracy. This results in a trade-off
  //     that must be adjusted according to the application.
  //  -> ADC Conversion Clock Options (ADICLK): 00 IPG clock
  //                                            01 IPG clock divided by 2
  //                                            10 Reserved
  //                                            11 Asynchronous clock (ADACK)* 
  // * ADC Asynchronous Clock Source: (page 66, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors) 
  //   ADHSC=0 -> fADACK = 10 MHz 
  //   ADHSC=1 -> fADACK = 20 MHz

  //  => Change the ADC clock according your application
  //  => IN THIS EXAMPLE, Asynchronous clock (ADACK) will be used, which is a dedicated clock used only by the ADC (20MHz - Divider 1, ADHSC=1 ).
#define ADC1_CLOCK_SOURCE 1  // 0: IPG/2/4 (18.75 MHz) | 1: ADACK (20MHz)   

  ADC1_CFG &= ~(ADC_CFG_ADICLK(3));  // Clear ADICLK (00-> IPG CLK)
  ADC1_CFG &= ~(ADC_CFG_ADIV(3));    // Clear ADIV   (00-> divider=1)

#if (ADC1_CLOCK_SOURCE == 0)          // Option 0: IPG/2
    //the lines below configure ADC Conversion Clk for  18.75 MHz, based on IPG CLK  =>  150MHz/2/4 = 18.75 MHz
  ADC1_CFG |= ADC_CFG_ADICLK(1);     // ADICLK = 01
  ADC1_CFG |= ADC_CFG_ADIV(2);       // ADIV = 10 (Div by 4)
    
#elif (ADC1_CLOCK_SOURCE == 1)        // Option 1: ADACK
  ADC1_GC  |= ADC_GC_ADACKEN;        // Enable the oscillator (ADACKEN) -> Force ADACK oscillator to run continuously (Higher Power Consumption)
                                     //  to reduce the latency of initiating a single or first-continuous conversion
  ADC1_CFG |= ADC_CFG_ADICLK(3);     // ADICLK = 11
  #else
    #error "Invalid ADC_CLOCK_SOURCE selected!"
#endif

  //For a shorter sampling time, use LPC=0 and HSC=1. See page 68, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors.
  ADC1_CFG |= ADC_CFG_ADHSC;       // Select high speed conversion (HSC=1)
  ADC1_CFG &= ~(ADC_CFG_ADLPC);    // ADC hard block not in low power mode (LPC=0)

  ADC1_CFG &= ~(ADC_CFG_MODE(3));  // Clear MODE
  ADC1_CFG |= ADC_CFG_MODE(2);     // MODE = 0b10 -> 12-bit conversion

  // Sample time configuration
  ADC1_CFG &= ~(ADC_CFG_ADLSMP);   // LSMP=0 -> Short sample mode
  ADC1_CFG &= ~(ADC_CFG_ADSTS(3)); // Clear STS
  ADC1_CFG |= ADC_CFG_ADSTS(2);    // Set STS=0b10 => Sample period (ADC clocks) = 7 if ADLSMP=0b => 1/20MHz*7= 350ns

  ADC1_CFG |= ADC_CFG_ADTRG;       // Selects Hardware trigger - The ADC_ETC module will be configured to trigger the ADC.
  ADC1_GC &= ~(ADC_GC_ADCO);       // Ensures that the ADC waits for the ADC_ETC trigger (not in continuous conversion mode)

  ADC1_GC &= ~(ADC_GC_AVGE);       // Hardware Average disabled => If Enabled -> configure the number of samples below
  // ADC1_CFG &= ~(ADC_CFG_AVGS(3));  // Clear AVGS  
  // ADC1_CFG |= ADC_CFG_AVGS(2);     // Set AVGS: 0b00 - 4 samples averaged; 0b01 - 8 samples averaged; 0b10 - 16 samples averaged; 0b11 32 samples averaged 

  ADC1_HC0 = 16; // The ADC_ETC will be used to select the channel on trigger0 (slot 0) of ADC1.
                 // See page 3431, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors 
                 // Configure ADCx_HCn for all slots used by ADC_ETC
  
  //Note: Other parameters must be in accordance with the reset condition. If the ADC exhibits improper operation, check the additional configuration
  //      bits in the manual.      
}

// ==========================================================================================================
void init_ADC2(void) {
   // Enable Clock for ADC2 using the macro defined in imxrt.h
  CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON); // Enable ADC2 Clock -> Bits:15–14 CG7, page 1079, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
  //Even when using the Asynchronous Clock Source as ADC Conversion Clock, it is necessary to enable the clock for the ADC in the Clock Control Module (CCM),
  // because the operation of the peripheral interface (the registers you read and write) is still clocked by the system bus clock (IPG clock).

  // **** Select ADC Conversion Clock ****
  //  Notes:
  //  -> In page 65, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors, it is said that the operating frequency
  //     of the ADC module can vary from a minimum of 4 MHz to a maximum of 40 MHz (ADLPC=0, not in low power mode; ADHSC=1, High speed conversion).
  //  -> It is important to keep in mind that there is a relationship between the operating frequency of the ADC and its accuracy, with greater accuracy 
  //     occurring at lower frequencies.
  //  -> Increasing the operating frequency allows for operation at higher sampling rates at the cost of reduced accuracy. This results in a trade-off
  //     that must be adjusted according to the application.
  //  -> ADC Conversion Clock Options (ADICLK): 00 IPG clock
  //                                            01 IPG clock divided by 2
  //                                            10 Reserved
  //                                            11 Asynchronous clock (ADACK)* 
  // * ADC Asynchronous Clock Source: (page 66, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors) 
  //   ADHSC=0 -> fADACK = 10 MHz 
  //   ADHSC=1 -> fADACK = 20 MHz

  //  => Change the ADC clock according your application
  //  => IN THIS EXAMPLE, Asynchronous clock (ADACK) will be used, which is a dedicated clock used only by the ADC (20MHz - Divider 1, ADHSC=1 ).
#define ADC2_CLOCK_SOURCE 1  // 0: IPG/2/4 (18.75 MHz) | 1: ADACK (20MHz)   

  ADC2_CFG &= ~(ADC_CFG_ADICLK(3));  // Clear ADICLK (00-> IPG CLK)
  ADC2_CFG &= ~(ADC_CFG_ADIV(3));    // Clear ADIV   (00-> divider=1)

#if (ADC2_CLOCK_SOURCE == 0)          // Option 0: IPG/2
    //the lines below configure ADC Conversion Clk for  18.75 MHz, based on IPG CLK  =>  150MHz/2/4 = 18.75 MHz
  ADC2_CFG |= ADC_CFG_ADICLK(1);     // ADICLK = 01
  ADC2_CFG |= ADC_CFG_ADIV(2);       // ADIV = 10 (Div by 4)
    
#elif (ADC2_CLOCK_SOURCE == 1)        // Option 1: ADACK
  ADC2_GC  |= ADC_GC_ADACKEN;        // Enable the oscillator (ADACKEN) -> Force ADACK oscillator to run continuously (Higher Power Consumption)
                                     //  to reduce the latency of initiating a single or first-continuous conversion
  ADC2_CFG |= ADC_CFG_ADICLK(3);     // ADICLK = 11
  #else
    #error "Invalid ADC_CLOCK_SOURCE selected!"
#endif

  //For a shorter sampling time, use LPC=0 and HSC=1. See page 68, i.MX RT1060 Crossover Processors for Consumer Products, Rev. 4, 04/2024, NXP Semiconductors.
  ADC2_CFG |= ADC_CFG_ADHSC;       // Select high speed conversion (HSC=1)
  ADC2_CFG &= ~(ADC_CFG_ADLPC);    // ADC hard block not in low power mode (LPC=0)

  ADC2_CFG &= ~(ADC_CFG_MODE(3));  // Clear MODE
  ADC2_CFG |= ADC_CFG_MODE(2);     // MODE = 0b10 -> 12-bit conversion

  // Sample time configuration
  ADC2_CFG &= ~(ADC_CFG_ADLSMP);   // LSMP=0 -> Short sample mode
  ADC2_CFG &= ~(ADC_CFG_ADSTS(3)); // Clear STS
  ADC2_CFG |= ADC_CFG_ADSTS(2);    // Set STS=0b10 => Sample period (ADC clocks) = 7 if ADLSMP=0b => 1/20MHz*7= 350ns

  ADC2_CFG |= ADC_CFG_ADTRG;       // Selects Hardware trigger - The ADC_ETC module will be configured to trigger the ADC.
  ADC2_GC &= ~(ADC_GC_ADCO);       // Ensures that the ADC waits for the ADC_ETC trigger (not in continuous conversion mode)

  ADC2_GC &= ~(ADC_GC_AVGE);       // Hardware Average disabled => If Enabled -> configure the number of samples below
  // ADC2_CFG &= ~(ADC_CFG_AVGS(3));  // Clear AVGS  
  // ADC2_CFG |= ADC_CFG_AVGS(2);     // Set AVGS: 0b00 - 4 samples averaged; 0b01 - 8 samples averaged; 0b10 - 16 samples averaged; 0b11 32 samples averaged 

  ADC2_HC0 = 16; // The ADC_ETC will be used to select the channel on trigger0 (slot 0) of ADC1.
                 // See page 3431, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors 
                 // Configure ADCx_HCn for all slots used by ADC_ETC
  
  //Note: Other parameters must be in accordance with the reset condition. If the ADC exhibits improper operation, check the additional configuration
  //      bits in the manual.      
}

// ==========================================================================================================
void ADC1_Calibrate(void) {
  // According to the i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors, page 3419, the ADC must be calibrated
  // using the exact settings you intend to use in your end application (ADC's clock source and frequency, low power configuration, voltage reference selection,
  // sample time, averaging, and the high speed); therefore, configure the ADC before calling this subroutine.

  uint32_t ADC1_config = ADC1_CFG; //save ADC1 hardware trigger option
  ADC1_CFG &= ~ADC_CFG_ADTRG;      //reset hardware trigger for calibration process,  page 3419, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021 

  //  Start Calibration
  ADC1_GC |= ADC_GC_CAL;

  //  Timeout Loop (10ms max)
  volatile uint8_t timeout = 10; 
  while ((ADC1_GC & ADC_GC_CAL) && (timeout > 0)) {
        delay(1); // Wait 1ms 
        timeout--;
  }

  // Calibration Result
  if (timeout == 0)
        {
          Serial.println("Timeout in the ADC1 calibration process!");
        } 
  else if (ADC1_GS & ADC_GS_CALF)   // Check CAL flag
             {
               Serial.println("The ADC1 calibration process failed!");
               ADC1_GS |= ADC_GS_CALF; // Clear the fail flag
             }
       else
             {
               uint32_t cal_code = (ADC1_CAL & 0x0F);
               Serial.println("The ADC1 calibration process was was completed successfully!");
               Serial.print("CAL_CODE = ");
               Serial.println(cal_code);
             }
  ADC1_CFG =  ADC1_config; //restore ADC1 hardware trigger option          
}

// ==========================================================================================================
void ADC2_Calibrate(void) {
  // According to the i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, NXP Semiconductors, page 3419, the ADC must be calibrated
  // using the exact settings you intend to use in your end application (ADC's clock source and frequency, low power configuration, voltage reference selection,
  // sample time, averaging, and the high speed); therefore, configure the ADC before calling this subroutine.

  uint32_t ADC2_config = ADC2_CFG; //save ADC1 hardware trigger option
  ADC2_CFG &= ~ADC_CFG_ADTRG;      //reset hardware trigger for calibration process,  page 3419, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021 

  //  Start Calibration
  ADC2_GC |= ADC_GC_CAL;

  //  Timeout Loop (10ms max)
  volatile uint8_t timeout = 10; 
  while ((ADC2_GC & ADC_GC_CAL) && (timeout > 0)) {
        delay(1); // Wait 1ms 
        timeout--;
  }

  // Calibration Result
  if (timeout == 0)
        {
          Serial.println("Timeout in the ADC2 calibration process!");
        } 
  else if (ADC2_GS & ADC_GS_CALF)   // Check CAL flag
             {
               Serial.println("The ADC1 calibration process failed!");
               ADC2_GS |= ADC_GS_CALF; // Clear the fail flag
             }
       else
             {
               uint32_t cal_code = (ADC2_CAL & 0x0F);
               Serial.println("The ADC2 calibration process was was completed successfully!");
               Serial.print("CAL_CODE = ");
               Serial.println(cal_code);
             }
  ADC2_CFG =  ADC2_config; //restore ADC1 hardware trigger option          
}

// ==========================================================================================================
void init_ADC_ETC(void) {
  // Using this routine implies that:
  //  - The ADC1 and ADC2 modules have been configured for Hardware Triggering;
  //  - ADCH = 0b10000 in ADC_HCn register for external channel selection from ADC_ETC (applied to used triggers)
  //  - The ADC_ETC_TRIG00 signal will be activated, therefore configure an appropriate trigger signal on the XBAR1 module.

  ADC_ETC_CTRL |= ADC_ETC_CTRL_SOFTRST; // software reset
  asm volatile("dsb"); // wait for set SOFTRST bit
  delay(10);           // wait for reset process
  ADC_ETC_CTRL &= ~ADC_ETC_CTRL_SOFTRST; // normal operation
  ADC_ETC_CTRL &= ~ADC_ETC_CTRL_TSC_BYPASS; // NOTE: To use ADC2, this bit should be cleared. 
                                            // See page 3459, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021 - NXP Semiconductors
  asm volatile("dsb"); // wait for reset SOFTRST bit
  delay(10);           // wait for normal operation starts  

  ADC1_Clear_Coco(); //Clear ADC1 Conversion Complete Flags - This is a kind of reset of ADC1 (just in case...)     
  ADC2_Clear_Coco(); //Clear ADC2 Conversion Complete Flags - This is a kind of reset of ADC2 (just in case...)     
 
  // Trigger 0 Chain with 1 segment (1 channel for sampling via ADC1) (N+1)
  // Trigger 4 Chain with 1 segment (1 channel for sampling via ADC2) (N+1)
  // SYNC_MODE is 1 => the hardware internally links the TRIG0 (ADC1) to TRIG4 (ADC2) 
  // Priority does not matter, no other trigger to compete for the ADC's attention.
  // Select Hardware trigger mode
  ADC_ETC_TRIG0_CTRL = ADC_ETC_TRIG_CTRL_SYNC_MODE |    // Set sync mode bit - This bit can be set to trig0 or trig4 or both; the result is the same. 
                       ADC_ETC_TRIG_CTRL_TRIG_CHAIN(0); // "0" means 1 item (N+1) -> 1 segment for ADC1
 
  ADC_ETC_TRIG4_CTRL = //ADC_ETC_TRIG_CTRL_SYNC_MODE |    // Set sync mode bit 
                       ADC_ETC_TRIG_CTRL_TRIG_CHAIN(0); // "0" means 1 item (N+1) -> 1 segment for ADC2

  // Configure the linked Trigger0 and Trigger 4 Chains
  // Trigger0: Segment 0: ADC1 (HWTS 0), Channel 7 (A0), Interrupt Enabled (IE=01)
  // Trigger4: Segment 4: ADC1 (HWTS 0), Channel 8 (A1), Interrupt Enabled (IE=01)
  // Interrupt configuration:  00b-No interrupt; 01b-interrupt on Done0; 10b-interrupt on Done1; 11b-interrupt on Done2 
  ADC_ETC_TRIG0_CHAIN_1_0 =                   //Trigger 0 (ADC1) chain configuration
       ADC_ETC_TRIG_CHAIN_B2B0           |    // Back to Back ADC trigger (B2B) is not applied, B2B doesn't matter here because this is the first and only conversion.
       ADC_ETC_TRIG_CHAIN_HWTS0(1 << 0)  |    // LOWER WORD: Target ADC1 Slot 0 (HC0) for first sample
       ADC_ETC_TRIG_CHAIN_CSEL0(A0)      |    //             Sample A0 (Hardware Channel 7)
       ADC_ETC_TRIG_CHAIN_IE0(1)         ;    //             interrupt on Done0 enabled

  ADC_ETC_TRIG4_CHAIN_1_0 =                   //Trigger 4 (ADC2) chain configuration
       ADC_ETC_TRIG_CHAIN_B2B0           |    // Back to Back ADC trigger (B2B) is not applied, B2B doesn't matter here because this is the first and only conversion.
       ADC_ETC_TRIG_CHAIN_HWTS0(1 << 0)  |    // LOWER WORD: Target ADC1 Slot 0 (HC0) for first sample
       ADC_ETC_TRIG_CHAIN_CSEL0(A1)      |    //             Sample A1 (Hardware Channel 8)
       ADC_ETC_TRIG_CHAIN_IE0(1)         ;    //             interrupt on Done0 enabled

// IMPORTANT NOTE FOR MULTIPLE CHANNELS IN THE CHAIN (It is not the case in this example):
//                 If B2B is set for all segments of the chain above (except the first), there is no need to configure the sampling interval. 
//                 If B2B = 0 for any segment other than the first, the sampling interval must be adjusted to a delay greater than the total
//                  sampling time (sampling time + conversion time). In this example, we have 1 channel in the chain, so  B2B is not applied (it doesn't matter).
//ADC_ETC_CTRL |= ADC_ETC_CTRL_PRE_DIVIDER(1);   // configure pre_divider = 0 (8-bits) for initial delay and sample interval
//ADC_ETC_TRIG0_COUNTER =   ADC_ETC_TRIG_COUNTER_INIT_DELAY(0) |       // Initial_delay (16-bits) = (INIT_DELAY+1)*(PRE_DIVIDER+1)*ipg_clk
//                          ADC_ETC_TRIG_COUNTER_SAMPLE_INTERVAL(136); // Interval_delay = (SAMPLE_INTERVAL+1)*(PRE_DIVIDER+1)*ipg_clk

  // Install the ISR to IRQ 118 (Done0)
  attachInterruptVector(IRQ_ADC_ETC0, &adc_etc_done0_isr); 
  // Set priority (optional, 128 is default)
  NVIC_SET_PRIORITY(IRQ_ADC_ETC0, 0x80);  // Only the superior nibble is considered => 128=0x80= 1000 0000 => Level 8 out of 15 (16 levels)
    // Enable the IRQ in the Nested Vectored Interrupt Controller
  NVIC_ENABLE_IRQ(IRQ_ADC_ETC0); // Enable the IRQ in NVIC (Nested Vectored Interrupt Controller) => Interrupt at ADC_ETC was enabled above
  
  // Install the ISR to IRQ 121 (TRIG0_ERR)
  attachInterruptVector(IRQ_ADC_ETC_ERR, &adc_etc_error_isr);
  // Set priority (optional)
  NVIC_SET_PRIORITY(IRQ_ADC_ETC_ERR, 0x70);  // Only the superior nibble is considered => 0x70= 0111 0000 => Level 7 out of 15 (16 levels)
  // Enable the IRQ in the Nested Vectored Interrupt Controller
  NVIC_ENABLE_IRQ(IRQ_ADC_ETC_ERR);

  // Configure ADC_ETC Global Control - Enable trigger 0
  ADC_ETC_CTRL |= ADC_ETC_CTRL_TRIG_ENABLE(1 << 0); //Only TRIG00 is enabled:  0x10 - TRIG10; 0x01 - TRIG00  => 0xFF enable all 8 triggers
                                                    //                         0x20 - TRIG11; 0x02 - TRIG01
                                                    //                         0x40 - TRIG12; 0x04 - TRIG02
                                                    //                         0x80 - TRIG13; 0x08 - TRIG03

  //Notes: - Other parameters must be in accordance with the reset condition. 
  //       - TRIGGER sampling interval and initial delay in default values (ETC_TRIG Counter Register)
}

// ==========================================================================================================
void config_XBAR1(void){
  // ===== XBAR1 Configuration =====
  CCM_CCGR2 |= CCM_CCGR2_XBAR1(CCM_CCGR_ON); // Enable Clock for XBARA1
  // Route FlexPWM4_SM2_TRIG0 OR FLEXPWM4_PWM2_OUT_TRIG1 (XBAR1_IN54) to ADC_ETC_TRIG00 (XBAR1_OUT103)
  // Note that FLEXPWM4_PWM2_OUT_TRIG0 and FLEXPWM4_PWM2_OUT_TRIG1 share the XBAR1_IN54 input through a logical OR operation.
  // XBARA1_SEL51 handles Output 102 (bits 6:0) and Output 103 (bits 14:8) => number of input in 7-bits
  XBARA1_SEL51 &= ~0x7F00;    // Clear SEL103 (XBAR1_OUT103)
  XBARA1_SEL51 |= (54 << 8);  // Set XBAR1_OUT103 to XBAR1_IN54, note that the configuration of interest is in the upper byte (bits 14-8)
  // => IMPORTANT NOTE: In i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021, Table 4-5. - XBAR1 Input Assignments, page 62, FlexPWM4_SM2_TRIG0 and 
  //    FLEXPWM4_PWM2_OUT_TRIG1 are assigned to XBAR1_IN53, I think this is a mistake, since the current code is working!  
}

// ==========================================================================================================
void ADC1_Clear_Coco(void) //Clear ADC1 Conversion Complete Flags
{
    //Reset COCO flags - page 3412, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
    volatile uint32_t dummy; 
    dummy = ADC1_R0;
    dummy = ADC1_R1;
    dummy = ADC1_R2;
    dummy = ADC1_R3;
    dummy = ADC1_R4;
    dummy = ADC1_R5;
    dummy = ADC1_R6;
    dummy = ADC1_R7; 
}

// ==========================================================================================================
void ADC2_Clear_Coco(void) //Clear ADC2 Conversion Complete Flags
{
    //Reset COCO flags - page 3412, i.MX RT1060 Processor Reference Manual, Rev. 3, 07/2021
    volatile uint32_t dummy; 
    dummy = ADC2_R0;
    dummy = ADC2_R1;
    dummy = ADC2_R2;
    dummy = ADC2_R3;
    dummy = ADC2_R4;
    dummy = ADC2_R5;
    dummy = ADC2_R6;
    dummy = ADC2_R7; 
}

// ==========================================================================================================
